Input = attr(block_info, "input"),
Output = attr(block_info, "output"),
Package = attr(block_info, "package"),
stringsAsFactors = FALSE
)
blocks_info <- rbind(blocks_info, new_row)
}
return(blocks_info)
}
# Example usage with the provided blocks
# blocks_table <- parse_block_descriptions(list_of_blocks)
# print(blocks_table)
# block_descriptions_parser.R
# Define a function to parse block descriptions and create a table
parse_block_descriptions <- function(block_descriptions) {
# Create an empty data frame to hold the extracted information
blocks_info <- data.frame(
Name = character(),
Description = character(),
Classes = character(),
Input = character(),
Output = character(),
Package = character(),
stringsAsFactors = FALSE
)
# Iterate over each block description and extract information
for (block in names(block_descriptions)) {
block_info <- block_descriptions[[block]]
new_row <- data.frame(
Name = attr(block_info, "name"),
Description = attr(block_info, "description"),
Classes = paste(attr(block_info, "classes"), collapse = ", "),
Input = attr(block_info, "input"),
Output = attr(block_info, "output"),
Package = attr(block_info, "package"),
stringsAsFactors = FALSE
)
blocks_info <- rbind(blocks_info, new_row)
}
return(blocks_info)
}
# Example usage with the provided blocks
# blocks_table <- parse_block_descriptions(available_blocks)
# print(blocks_table)
parse_block_descriptions(available_blocks)
parse_block_descriptions(available_blocks())
library(shiny); runApp('inst/examples/add-blocks/new_blocks_app.R')
library(shiny); runApp('inst/examples/add-blocks/new_blocks_app.R')
?lm
lm(Sepal.Length~Sepal.Width, iris)
lm("Sepal.Length~Sepal.Width", iris)
lm("Sepal.Length~Sepal.Width", iris) |> as.data.frame()
install.packages("broom")
lm("Sepal.Length~Sepal.Width", iris) |> broom::tidy()
blockr::create_block("lm", type = c("transform"))
library(blockr)
library(shiny)
library(blockr.data)
library(blockr)
register_block(
constructor = new_upload_block,
name = "upload block",
description = "upload a single file",
classes = c("upload_block", "data_block"),
input = NA_character_,
output = "data.frame"
)
register_block(
constructor = lm_block,
name = "linear model block",
description = "Enter a formula",
classes = c("lm_block", "transform_block"),
input = "data.frame",
output = "data.frame"
)
devtools::document()
library(shiny)
library(blockr.data)
library(blockr)
register_block(
constructor = new_upload_block,
name = "upload block",
description = "upload a single file",
classes = c("upload_block", "data_block"),
input = NA_character_,
output = "data.frame"
)
register_block(
constructor = lm_block,
name = "linear model block",
description = "Enter a formula",
classes = c("lm_block", "transform_block"),
input = "data.frame",
output = "data.frame"
)
available_blocks()
runApp('inst/examples/add-blocks/new_blocks_app.R')
runApp('inst/examples/add-blocks/new_blocks_app.R')
runApp('inst/examples/add-blocks/new_blocks_app.R')
blockr::create_block("corrplot", type = "plot")
corplot
install.packages("corrplot")
?corrplot
?corrplot
library(blockr)
runApp('inst/examples/add-blocks/new_blocks_app.R')
runApp('inst/examples/add-blocks/new_blocks_app.R')
devtools::document()
runApp('inst/examples/add-blocks/new_blocks_app.R')
set.seed(123) # For reproducibility
data <- as.data.frame(matrix(rnorm(400), ncol = 20)) # 20 variables
datasets::demo
blockr.data::demo
blockr.data::demo |> select(AGE, DMY) |> cor()
blockr.data::demo |> select(AGE, DMDY) |> cor()
blockr.data::demo |> select(AGE, DMDY) |> cor() |> corrplot()
blockr.data::demo |> select(AGE, DMDY) |> cor() |> corrplot::corrplot()
blockr.data::demo |> select(AGE, DMDY) |> cor() |> corrplot::corrplot(title = "heyy")
blockr.data::demo |> select(AGE, DMDY) |> cor() |> corrplot::corrplot(title = "heyy", method = "square")
blockr.data::demo |> select(AGE, DMDY) |> cor() |> corrplot::corrplot(title = "heyy", method = "square", type = "lower")
blockr.data::demo |> select(AGE, DMDY) |> cor() |> corrplot::corrplot(title = "heyy", method = "square", type = "lower", order = "alphabet")
blockr.data::demo |> select(AGE, DMDY) |> cor() |> corrplot::corrplot(title = "heyy", method = "square", type = "lower", order = "alphabet")
blockr.data::demo |> select(AGE, DMDY) |> cor() |> corrplot::corrplot(title = "heyy", method = "circle", type = "lower", order = "alphabet")
runApp('inst/examples/add-blocks/new_blocks_app.R')
blockr.data::demo |> select(AGE, DMDY) |> cor() |> corrplot::corrplot(title = "heyy", method = "circle", type = "lower", order = "alphabet") |> class()
runApp('inst/examples/add-blocks/new_blocks_app.R')
?new_select_field
library(blockr)
devtools::document()
runApp('inst/examples/add-blocks/new_blocks_app.R')
blockr.data::demo |> select(AGE, DMDY) |> cor() |> corrplot::corrplot(title = "heyy", method = "circle", type = "full", order = "original")
runApp('inst/examples/add-blocks')
runApp('inst/examples/add-blocks/new_blocks_app.R')
library(blockr)
devtools::document()
runApp('inst/examples/add-blocks/new_blocks_app.R')
pkgload::load_all()
new_corrplot_block <- function(data, ...) {
fields <- list(
method = new_select_field("circle", choices= c("circle", "square", "ellipse", "number", "shade", "color", "pie")),
type = new_select_field("full", choices= c("full", "lower", "upper")),
order = new_select_field("original",choices= c("original", "AOE", "FPC", "hclust", "alphabet")),
title = new_string_field()
)
new_block(
fields = fields,
expr = quote({
corr_matrix <- stats::cor(data)
corrplot::corrplot(corr_matrix, method = .(method), type = .(type),
order = .(order), addrect = 2, tl.col = "black", tl.srt = 45,
diag = FALSE,
title = .(title)
) #
}),
...,
class = c("corrplot_block", "plot_block")
)
}
corrplot_block <- function(data, ...) {
initialize_block(new_corrplot_block(data, ...), data)
}
register_block(
constructor = corrplot_block,
name = "corrplot block",
description = "Creates a correlation plot",
classes = c("corrplot_block", "plot_block"),
input = "data.frame",
output = "list"
)
stack <- new_stack(data_block)
shinyApp(
ui = bslib::page_fluid(
add_block_ui(),
generate_ui(stack, id = "mystack")
),
server = function(input, output, session) {
vals <- reactiveValues(new_block = NULL)
stack <- generate_server(
stack,
id = "mystack",
new_block = reactive(vals$new_block)
)
observeEvent(input$add, {
vals$new_block <- NULL
# Always append to stack
loc <- length(stack$blocks)
block <- available_blocks()[[input$selected_block]]
# add_block expect the current stack, the block to add and its position
# (NULL is fine for the position, in that case the block will
# go at the end)
vals$new_block <- list(
block = block,
position = loc
)
})
}
)
pkgload::load_all()
new_corrplot_block <- function(data, ...) {
fields <- list(
method = new_select_field("circle", choices= c("circle", "square", "ellipse", "number", "shade", "color", "pie")),
type = new_select_field("full", choices= c("full", "lower", "upper")),
order = new_select_field("original",choices= c("original", "AOE", "FPC", "hclust", "alphabet")),
title = new_string_field()
)
new_block(
fields = fields,
expr = quote({
corr_matrix <- stats::cor(data)
corrplot::corrplot(corr_matrix, method = .(method), type = .(type),
order = .(order), addrect = 2, tl.col = "black", tl.srt = 45,
diag = FALSE,
title = .(title)
) #
}),
...,
class = c("corrplot_block", "plot_block")
)
}
corrplot_block <- function(data, ...) {
initialize_block(new_corrplot_block(data, ...), data)
}
register_block(
constructor = corrplot_block,
name = "corrplot block",
description = "Creates a correlation plot",
classes = c("corrplot_block", "plot_block"),
input = "data.frame",
output = "list"
)
stack <- new_stack(data_block)
shinyApp(
ui = bslib::page_fluid(
add_block_ui(),
generate_ui(stack, id = "mystack")
),
server = function(input, output, session) {
vals <- reactiveValues(new_block = NULL)
stack <- generate_server(
stack,
id = "mystack",
new_block = reactive(vals$new_block)
)
observeEvent(input$add, {
vals$new_block <- NULL
# Always append to stack
loc <- length(stack$blocks)
block <- available_blocks()[[input$selected_block]]
# add_block expect the current stack, the block to add and its position
# (NULL is fine for the position, in that case the block will
# go at the end)
vals$new_block <- list(
block = block,
position = loc
)
})
}
)
pkgload::load_all()
new_corrplot_block <- function(data, ...) {
fields <- list(
method = new_select_field("circle", choices= c("circle", "square", "ellipse", "number", "shade", "color", "pie")),
type = new_select_field("full", choices= c("full", "lower", "upper")),
order = new_select_field("original",choices= c("original", "AOE", "FPC", "hclust", "alphabet")),
title = new_string_field()
)
new_block(
fields = fields,
expr = quote({
corr_matrix <- stats::cor(data)
corrplot::corrplot(corr_matrix, method = .(method), type = .(type),
order = .(order), addrect = 2, tl.col = "black", tl.srt = 45,
diag = FALSE,
title = .(title)
) #
}),
...,
class = c("corrplot_block", "plot_block")
)
}
corrplot_block <- function(data, ...) {
initialize_block(new_corrplot_block(data, ...), data)
}
register_block(
constructor = corrplot_block,
name = "corrplot block",
description = "Creates a correlation plot",
classes = c("corrplot_block", "plot_block"),
input = "data.frame",
output = "list"
)
stack <- new_stack(data_block)
shinyApp(
ui = bslib::page_fluid(
add_block_ui(),
generate_ui(stack, id = "mystack")
),
server = function(input, output, session) {
vals <- reactiveValues(new_block = NULL)
stack <- generate_server(
stack,
id = "mystack",
new_block = reactive(vals$new_block)
)
observeEvent(input$add, {
vals$new_block <- NULL
# Always append to stack
loc <- length(stack$blocks)
block <- available_blocks()[[input$selected_block]]
# add_block expect the current stack, the block to add and its position
# (NULL is fine for the position, in that case the block will
# go at the end)
vals$new_block <- list(
block = block,
position = loc
)
})
}
)
data_block()
pkgload::load_all()
stack <- new_stack(data_block)
shinyApp(
ui = bslib::page_fluid(
add_block_ui(),
generate_ui(stack, id = "mystack")
),
server = function(input, output, session) {
vals <- reactiveValues(new_block = NULL)
stack <- generate_server(
stack,
id = "mystack",
new_block = reactive(vals$new_block)
)
observeEvent(input$add, {
vals$new_block <- NULL
# Always append to stack
loc <- length(stack$blocks)
block <- available_blocks()[[input$selected_block]]
# add_block expect the current stack, the block to add and its position
# (NULL is fine for the position, in that case the block will
# go at the end)
vals$new_block <- list(
block = block,
position = loc
)
})
}
)
cor(iris)
library(blockr)
devtools::document()
runApp('inst/examples/add-blocks/new_blocks_app.R')
pkgload::load_all()
new_corrplot_block <- function(data, ...) {
fields <- list(
method = new_select_field("circle", choices= c("circle", "square", "ellipse", "number", "shade", "color", "pie")),
type = new_select_field("full", choices= c("full", "lower", "upper")),
order = new_select_field("original",choices= c("original", "AOE", "FPC", "hclust", "alphabet")),
title = new_string_field()
)
new_block(
fields = fields,
expr = quote({
corr_matrix <- stats::cor(data)
corrplot::corrplot(corr_matrix, method = .(method), type = .(type),
order = .(order), addrect = 2, tl.col = "black", tl.srt = 45,
diag = FALSE,
title = .(title)
) #
}),
...,
class = c("corrplot_block", "plot_block")
)
}
corrplot_block <- function(data, ...) {
initialize_block(new_corrplot_block(data, ...), data)
}
register_block(
constructor = corrplot_block,
name = "corrplot block",
description = "Creates a correlation plot",
classes = c("corrplot_block", "plot_block"),
input = "data.frame",
output = "list"
)
stack <- new_stack(data_block)
shinyApp(
ui = bslib::page_fluid(
add_block_ui(),
generate_ui(stack, id = "mystack")
),
server = function(input, output, session) {
vals <- reactiveValues(new_block = NULL)
stack <- generate_server(
stack,
id = "mystack",
new_block = reactive(vals$new_block)
)
observeEvent(input$add, {
vals$new_block <- NULL
# Always append to stack
loc <- length(stack$blocks)
block <- available_blocks()[[input$selected_block]]
# add_block expect the current stack, the block to add and its position
# (NULL is fine for the position, in that case the block will
# go at the end)
vals$new_block <- list(
block = block,
position = loc
)
})
}
)
pkgload::load_all()
new_corrplot_block <- function(data, ...) {
fields <- list(
method = new_select_field("circle", choices= c("circle", "square", "ellipse", "number", "shade", "color", "pie")),
type = new_select_field("full", choices= c("full", "lower", "upper")),
order = new_select_field("original",choices= c("original", "AOE", "FPC", "hclust", "alphabet")),
title = new_string_field()
)
new_block(
fields = fields,
expr = quote({
corr_matrix <- stats::cor(data)
corrplot::corrplot(corr_matrix, method = .(method), type = .(type),
order = .(order), addrect = 2, tl.col = "black", tl.srt = 45,
diag = FALSE,
title = .(title)
) #
}),
...,
class = c("corrplot_block", "plot_block")
)
}
corrplot_block <- function(data, ...) {
initialize_block(new_corrplot_block(data, ...), data)
}
register_block(
constructor = corrplot_block,
name = "corrplot block",
description = "Creates a correlation plot",
classes = c("corrplot_block", "plot_block"),
input = "data.frame",
output = "list"
)
stack <- new_stack(data_block)
library(blockr.data)
pkgload::load_all()
new_corrplot_block <- function(data, ...) {
fields <- list(
method = new_select_field("circle", choices= c("circle", "square", "ellipse", "number", "shade", "color", "pie")),
type = new_select_field("full", choices= c("full", "lower", "upper")),
order = new_select_field("original",choices= c("original", "AOE", "FPC", "hclust", "alphabet")),
title = new_string_field()
)
new_block(
fields = fields,
expr = quote({
corr_matrix <- stats::cor(data)
corrplot::corrplot(corr_matrix, method = .(method), type = .(type),
order = .(order), addrect = 2, tl.col = "black", tl.srt = 45,
diag = FALSE,
title = .(title)
) #
}),
...,
class = c("corrplot_block", "plot_block")
)
}
corrplot_block <- function(data, ...) {
initialize_block(new_corrplot_block(data, ...), data)
}
register_block(
constructor = corrplot_block,
name = "corrplot block",
description = "Creates a correlation plot",
classes = c("corrplot_block", "plot_block"),
input = "data.frame",
output = "list"
)
stack <- new_stack(data_block)
shinyApp(
ui = bslib::page_fluid(
add_block_ui(),
generate_ui(stack, id = "mystack")
),
server = function(input, output, session) {
vals <- reactiveValues(new_block = NULL)
stack <- generate_server(
stack,
id = "mystack",
new_block = reactive(vals$new_block)
)
observeEvent(input$add, {
vals$new_block <- NULL
# Always append to stack
loc <- length(stack$blocks)
block <- available_blocks()[[input$selected_block]]
# add_block expect the current stack, the block to add and its position
# (NULL is fine for the position, in that case the block will
# go at the end)
vals$new_block <- list(
block = block,
position = loc
)
})
}
)
ls(blockr)
ls("blockr")
