---
title: "3. Case study: create a plot block"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{3. Case study: create a plot block}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=FALSE, message=FALSE}
library(blockr)

note_box <- function(..., color) {
  htmltools::div(
    class = sprintf(
      "m-3 p-2 text-%s-emphasis bg-%s-subtle border border-%s-subtle rounded-3",
      color, color, color
    ),
    ...
  )
}
```

In this vignette, we show how to create a plot block layer by layer with the `{ggplot2}` package.

```{r, eval=TRUE, echo=FALSE}
note_box(
  "Before going further, please be sure to read the S3 chapter of advanced R: https://adv-r.hadley.nz/s3.html.", #nolint
  color = "warning"
)
```

## Introduction

### Anatomy of a `{ggplot2}` plot

With `{ggplot2}`, plots are built __layer__ by __layer__. It all starts with
`ggplot()` which initialises the ggplot object passing optional data and mappings.
Then, we add __geoms__, like `geom_point()`. Geoms also accept custom __mappings__ (overwrite mappings
passed to the first `ggplot()` call), data, as well as other parameters.
As a result, there are many ways to build a ggplot:

```r
# 1
ggplot(data = <DATA>, mapping = <MAPPING>) +
  geom_point()
# 2
ggplot(data = <DATA>) +
  geom_point(mapping = <MAPPING>) +
  geom_point(mapping = <MAPPING>)

# 3
ggplot() +
  geom_point(data = <DATA>, mapping = <MAPPING>) +
  geom_point(data = <DATA>, mapping = <MAPPING>)
```

In this tutorial, we go for the first option.

### To do list

What do we need to create?

It seems obvious to add new `ggplot_block()` and geom __constructors__. On the Shiny side, we have to handle the 
plot output element. Remember that the `server_output()` __generic__ is defined in the `{blockr}`
`server.R` script. It supports tables with `server_output.block()` and plots with `server_output.plot_block()`.
Therefore, we don't need to create another S3 method and have to make sure our new plot block inherits
from the `plot_block` class to __dispatch__ to the correct method. Most of our work will be on the block side since
we'll have to generate the plot layer by layer, where each layer is a block.

```{r, eval=TRUE, echo=FALSE}
note_box(
  "Notice that the current {blockr} plot_block isn't built layer by layer but as a huge monolitic structure", #nolint
  "which is certainly less flexible than what we show here.",
  color = "primary"
)
```

### Create the ggplot block

To create a new block, we call the `new_block()` constructor. It expects:

- __fields__: a list of field, which are translated into shiny inputs.
- __expr__: the expression returned by the block, necessary to produce an output and export the code.
- __name__: a name (randomly choosen, you don't need to worry about this).
- __class__: a class to dispatch to the relevant S3 methods.
- __layout__: an optional layout (default to `default_layout_fields()`).

Our block will have `c("ggplot_block", "plot_block")` as classes, some fields to pass mappings and we
leave the layout to the default choice. Note that the mapping field depends on the provided data. 
To stay simple, we assume to only handle `x` and `y` __aesthetics__.

```{r}
new_ggplot_block <- function(data, ...) {
  new_block(
    fields = list(
      # TO DO
    ),
    expr = quote(),
    class = c("ggplot_block", "plot_block"),
    ...
  )
}

ggplot_block <- function(data, ...) {
  initialize_block(new_ggplot_block(data, ...), data)
}
```

We finally end with `new_ggplot_block`, the internal constructor and 
`ggplot_block`, the user facing constructor. The next step is to create the mappings fields with 
two `new_select_field()`. Those fields are converted into shiny inputs, specifically `selectInput()`.
To set the field choices which depend on the data, we define the `data_cols` helper:

```r
data_cols <- function(data) colnames(data)
```

We modify `new_ggplot_block` such that:

```r
new_ggplot_block <- function(data, ...) {

  data_cols <- function(data) colnames(data)

  new_block(
    fields = list(
      x = new_select_field(colnames(data)[1], data_cols, type = "name"),
      y = new_select_field(colnames(data)[2], data_cols, type = "name")
    ),
    expr = quote(),
    class = c("ggplot_block", "plot_block"),
    ...
  )
}
```

Producing the expression, which is certainly the most "technical" part, as it involves a bit of __metaprogramming__. 
The expression must not be evaluated in the block, that's why it is wrapped in a `quote()`. 
`{blockr}` is then able to generate the expression with `generate_code()` and evaluate it with `evaluate_block()`.

Our ggplot expression can be written as:

```r
ggplot(mapping = aes(x = .(x), y = .(y)))
```

In the above expression, you may notice `.()`, which is actually required by `generate_code()`. Under the hoods, this is needed by `bquote()` which only evaluates arguments wrapped
by `.()` with variables from the environment. It makes it easier to use than `substitute()`, since we explicitly mark what we want to
evaluate.

All combined together, this eventually yields:

```r
new_ggplot_block <- function(data, ...) {

  data_cols <- function(data) colnames(data)

  new_block(
    fields = list(
      x = new_select_field(colnames(data)[1], data_cols, type = "name"),
      y = new_select_field(colnames(data)[2], data_cols, type = "name")
    ),
    expr = quote(
      ggplot(mapping = aes(x = .(x), y = .(y)))
    ),
    class = c("ggplot_block", "plot_block"),
    ...
  )
}
```

As you can, see the code base is reasonable.

### Create a geom block

Now that we have a valid `ggplot_block`, we want to add it a geometry. The easiest one is `geom_point()`.
To keep the vignette as simple as possible, we only handle one option, namely the point color. We
host this information in a `new_select_field()`, for instance:

```r
new_select_field("blue", c("blue", "green", "red"))
```

The expression is straightforward to get:

```r
geom_point(color = .(color)) # Don't forget to wrap it with quote(...).
```

Importantly, since we use `.(color)`, the field name must be __color__.

This finally gives us:

```r
new_geompoint_block <- function(data, mappings, ...) {

  new_block(
    fields = list(
      color = new_select_field("blue", c("blue", "green", "red"))
    ),
    expr = quote(
      geom_point(color = .(color))
    ),
    class = c("plot_layer_block", "plot_block"),
    ...
  )
}

geompoint_block <- function(data, ...) {
  initialize_block(new_geompoint_block(data, ...), data)
}
```

Note the class `plot_layer_block`. This is necessary to invoke the right `evaluate_block` 
method (to use `+` instead of `%>%`).


### Try it

We can try it on some data:

```r
stack <- new_stack(data_block, ggplot_block, geompoint_block)
serve_stack(stack)
```