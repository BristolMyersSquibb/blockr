---
title: "2. Blocks registry"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{2. Blocks registry}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=FALSE, message=FALSE}
library(blockr)
library(bslib)

note_box <- function(..., color) {
  htmltools::div(
    class = sprintf(
      "m-3 p-2 text-%s-emphasis bg-%s-subtle border border-%s-subtle rounded-3",
      color, color, color
    ),
    ...
  )
}
```

## Introduction

```{r, eval=TRUE, echo=FALSE}
note_box(
  "This part is likely more dedicated to developers than users. However,
  it might be useful whenever you design custom blocks and want to register
  them in `{blockr}`.",
  color = "primary"
)
```

The __registry__ is a __environment__ which provides access to multiple __blocks__ as well as some
metadata:

- The block __description__.
- Allowed __input__ (default to data.frame, expect for `data_block` blocks)
- Returned __output__.
- ...

## Previewing available blocks

Upon loading, `{blockr}` __registers__ its internal __blocks__ with `register_blockr_blocks()`.
You won't have to call this function as it is not exported anyway. This makes the __registry__ environment
ready to be queried by `available_blocks()`. A truncated output example below:

```r
$dataset_block
function(...) {
  initialize_block(new_dataset_block(...))
}
<environment: namespace:blockr>
attr(,"name")
[1] "data block"
attr(,"description")
[1] "choose a dataset"
attr(,"classes")
[1] "dataset_block" "data_block"   
attr(,"input")
[1] NA
attr(,"output")
[1] "data.frame"
attr(,"package")
[1] "blockr"
attr(,"class")
[1] "block_descr"

$select_block
function(data, ...) {
  initialize_block(new_select_block(data, ...), data)
}
<environment: namespace:blockr>
attr(,"name")
[1] "select block"
attr(,"description")
[1] "select columns in a table"
attr(,"classes")
[1] "select_block"    "transform_block"
attr(,"input")
[1] "data.frame"
attr(,"output")
[1] "data.frame"
attr(,"package")
[1] "blockr"
attr(,"class")
[1] "block_descr"
```

```{r, eval=TRUE}
names(available_blocks())
```

## Register a block
To register you own blocks, user facing functions are:

- `register_block()` to register a block in the __registry__. If the __block__ is already registered,
it __overwrites__ the existing one.
- `register_blocks()` to register multiple blocks.

Let's say you want to create a new `tail_block` which returns the `n` last rows of the
selected dataset:

```{r, eval=TRUE}
tail_block <- function(data, n_rows = numeric(), ...) {
  n_rows_max <- function(data) nrow(data)

  initialize_block(
    new_block(
      fields = list(
        n_rows = new_numeric_field(n_rows, 1L, n_rows_max)
      ),
      expr = quote(tail(n = .(n_rows))),
      class = c("tail_block", "transform_block"),
      ...
    ),
    data
  )
}

register_block(
  constructor = tail_block,
  name = "tail block",
  description = "return last n rows",
  classes = c("tail_block", "transform_block"),
  input = "data.frame",
  output = "data.frame"
)
```

If we now query the registry, the new block is available:

```{r, eval=TRUE}
names(available_blocks())
```

We can now run the demo app to add blocks. The new `tail_block` should be
visible in the new choices:

```{r, eval=TRUE, echo=FALSE}
card(
  create_app_link(
    "NobwRAdghgtgpmAXGKAHVA6ASmANGAYwHsIAXOMpMAdzgCMAnRRASwgGdSoAbbgCgA6YOtyIEA1gyG4ABAzioi7GQF4ZQgBalSqdogD0+kWMkBaIgwDmGSy1IaArnQwsi+2o1PzF7IQEoBCG4WRigGAE8+YwkGAKCQhjDI9g02cLjArhZuAH1o8RkAHlMZADMHCAJSVwg+ABMoLlkIHIYiamU1CAd4BhYCPj9ZDBG-GRBAwJkZFraOnJgoAA8ikvLK6pJ6xqgxiDntrjjpqZk2OxYeFgAvODzRCUEIaemIOGp7kyeXspY4bjqnRkwU43x+M1a7SBbw+3V6-RypT+AL4syhsgAjAAZZqQ+aLJbHF5DU7TOBLVAMVQyACODiI5D4WX4zzUGFRePYfm5uFJMgI3Cg7CBAyEzM+Emk6jApESHFKFhgEvE-l5zxeIwwfKG6nV0waXFOcQAvpN9nBbJw4AxlWDiBxZQ4qhZqeL8mrXrA4NSxVBsjJ8tJTnU4OwCH1UJtWdL5KQHAxnoLODM5FCg+qBUL2KHqaKZX7coG8NLZVB5YrlarTmxUA5SD6wAaoBhSol4OnpkQ67X62ohE2W224EJAhkHVAJKsZu8cpwJ+JDkK4KRlXEWHUp0IYOE55KwGaUmkAILoMEOFjUujsYJ0ZioKCWO6lbjnupg6aPt6Jcg5c98XfiLI65EiS6rZgwABu1rUusVQ1HwNZ1rIXY6EhMjZsKNRjBMeroVwk7FDIn7Wo0dzgVBDD-vhgFnHURKmhAfhgMaAC6QA", # nolint
    "app",
    header = FALSE
  ),
  full_screen = TRUE
)
```

If you had to register multiple blocks:

```r
register_blocks(
  constructor = c(
    dataset_block, filter_block, select_block, summarize_block
  ),
  name = c(
    "data block", "filter block", "select block", "summarize block"
  ),
  description = c(
    "choose a dataset",
    "filter rows in a table",
    "select columns in a table",
    "summarize data groups"
  ),
  classes = list(
    c("dataset_block", "data_block"),
    c("filter_block", "transform_block", "submit_block"),
    c("select_block", "transform_block"),
    c("summarize_block", "transform_block", "submit_block")
  ),
  input = c(NA_character_, "data.frame", "data.frame", "data.frame"),
  output = c("data.frame", "data.frame", "data.frame", "data.frame"),
  package = pkg
)
```

## Unregister a block

The counterpart of `register_block()` is `unregister_blocks()`. We can remove
our new `tail_block` from the registry:

```{r, eval=TRUE}
unregister_blocks(ids = "tail_block")

# Check it out
names(available_blocks())
```

where __ids__ is the first entry we applied in the class attributes when the block
was created, that is `tail_block`. If you had to remove multiple blocks at once,
you can pass a vector in __ids__.
